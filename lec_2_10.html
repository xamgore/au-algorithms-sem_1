<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<title>Заголовок</title>
<!-- Search Engine -->
<meta name="description" content="Есть много разных модлей вычислений: RAM-машина:  классическая модель вычислений, которую мы использовали до сих пор. Модель внешней памяти (cache-aware): ">
<meta name="image" content="https://demiurg906.github.io/au-algorithms-sem_1/preview.png">
<!-- Schema.org for Google -->
<meta itemprop="name" content="Заголовок">
<meta itemprop="description" content="Есть много разных модлей вычислений: RAM-машина:  классическая модель вычислений, которую мы использовали до сих пор. Модель внешней памяти (cache-aware): ">
<meta itemprop="image" content="https://demiurg906.github.io/au-algorithms-sem_1/preview.png">
<!-- Twitter -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Заголовок">
<meta name="twitter:description" content="Есть много разных модлей вычислений: RAM-машина:  классическая модель вычислений, которую мы использовали до сих пор. Модель внешней памяти (cache-aware): ">
<meta name="twitter:image:src" content="https://demiurg906.github.io/au-algorithms-sem_1/preview.png">
<!-- Twitter - Article -->
<!-- Open Graph general (Facebook, Pinterest & Google+) -->
<meta property="og:title" content="Заголовок">
<meta property="og:description" content="Есть много разных модлей вычислений: RAM-машина:  классическая модель вычислений, которую мы использовали до сих пор. Модель внешней памяти (cache-aware): ">
<meta property="og:image" content="https://demiurg906.github.io/au-algorithms-sem_1/preview.png">
<meta property="og:type" content="article">
<!-- Open Graph - Article -->

<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="https://demiurg906.github.io/au-algorithms-sem_1/assets/style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js" integrity="sha256-MRn7pN9LOBMrkp+8F2t5xb/92V1irzXp/dl5tUTwEgE=" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" integrity="sha256-tAflq+ymku3Khs+I/WcAneIlafYgDiOQ9stIHH985Wo=" crossorigin="anonymous" />
<script src="https://demiurg906.github.io/au-algorithms-sem_1/assets/xpath.js" type="text/javascript"></script>
<script>newIssue="https://github.com/demiurg906/au-algorithms-sem_1/issues/new"</script>
<script src="https://demiurg906.github.io/au-algorithms-sem_1/assets/load.js"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax:    {
    inlineMath:  [['$','$'],  ['\\(','\\)']],
    displayMath: [["$$","$$"],["\\[","\\]"]],
    displayAlign: "center"
    // processEscapes: true
  },
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
         SVG: { linebreaks: { automatic: true } }
});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
</script>
</head>
<body>
  <div id="mistake">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 402.938 402.938"><path d="M401.785 33.437C399.28 18.683 389.61 16.48 384.07 16.48c-22.935 0-65.053 36.684-109.644 75.52-18.23 15.88-37.083 32.3-53.502 45.048-5.858 4.548-11.803 9.103-18.097 13.924-31.276 23.96-66.726 51.12-94.16 80.356-26.887 28.65-42.593 55.62-47.676 81.98L4.12 364.683c-5.122 4.628-5.523 12.532-.896 17.655 2.468 2.732 5.867 4.12 9.28 4.12 2.987 0 5.984-1.063 8.375-3.223l47.816-43.194c2.31.634 5.016.963 8.19.963 27.39 0 93.534-24.866 153.857-57.84l6.043-3.305L226.11 269.8l17.888 5.932 1.947-1.13c15.867-9.21 30.165-18.41 42.496-27.338 2.19-1.586 4.45-3.292 7.115-5.372l3.87-3.02-11.223-14.93 20.26 7.21 2.218-2.02c15.51-14.13 29.805-30.467 42.486-48.554l2.428-3.462-18.606-18.342 25.257 8.17 2.054-3.37c28.307-46.454 43.02-97.535 37.485-130.137z"/></svg>
  </div>

  <article class="content">
      

      
      <div class="navigation">
        <a href="lec_2_09.html">← взад</a>
        <a href="index.html">к оглавлению</a>
        <a href="lec_2_11.html">вперёд →</a>
      </div>
      
      <h1 id="Другие-модели-вычислений"><a aria-hidden="true" href="#Другие-модели-вычислений"><span class="icon icon-link"></span></a>Другие модели вычислений</h1>
<p>Есть много разных модлей вычислений:</p>
<ul>
<li>
<p><strong>RAM-машина:</strong> классическая модель вычислений, которую мы использовали до сих пор.</p>
</li>
<li>
<p><strong>Модель внешней памяти (cache-aware):</strong> модель вычислений, в которой есть ограниченная оперативная память и более-менее безграничная внешняя память (жесткий диск, магнитные лента), с очень медленной скоростью доступа к ней (на несколько порядков меньше, чем у оперативной).</p>
<p>  Ключевым узким местом в данной модели являются операции чтения из внешней памяти, алгоритмы в оперативке считаются эффективными, и на их время работы можно забить.</p>
</li>
<li>
<p><strong>Cache-oblivious:</strong> эта модель схожа с моделью внешней памяти, но ничего не знаем про количество доступной памяти.</p>
</li>
<li>
<p><strong>Распределенные вычисления:</strong> есть множество машин с какой-то моедлью вычислений, которые могут общаться друг с другом по сети</p>
</li>
<li>
<p><strong>Квантовые комьютеры</strong></p>
</li>
<li>
<p><strong>Вычисления на GPU</strong></p>
</li>
<li>
<p><strong>Streaming алгоритмы:</strong> есть устройства с ограниченной памятью и вычислительной возможностью, необходимо работать с большими данными (роутер)</p>
</li>
</ul>
<h2 id="Модель-внешней-памяти"><a aria-hidden="true" href="#Модель-внешней-памяти"><span class="icon icon-link"></span></a>Модель внешней памяти</h2>
<p>Есть процессор и RAM размера <span class="inlineMath">$M$</span>, с которой он может работать. Также есть внешняя память и некоторый IO контроллер, который может выгружать данные из внешней памяти в RAM блоками размера <span class="inlineMath">$B$</span>.</p>
<p>Имеется два параметра -- <span class="inlineMath">$M$</span> И <span class="inlineMath">$B$</span>, интересует количество IO операций.</p>
<h3 id="Всякие-алгоритмы"><a aria-hidden="true" href="#Всякие-алгоритмы"><span class="icon icon-link"></span></a>Всякие алгоритмы</h3>
<h4 id="Поиск-в-массиве"><a aria-hidden="true" href="#Поиск-в-массиве"><span class="icon icon-link"></span></a>Поиск в массиве</h4>
<p>Есть массив размера <span class="inlineMath">$N$</span>, который линейно лежит в памяти, необходимо найти определнный элемент.</p>
<p>Тип поиска:</p>
<ul>
<li>Линейный поиск: <span class="inlineMath">$O(N / B)$</span> IO операций.</li>
<li>Бинарный поиск: <span class="inlineMath">$O(\log_2\frac NB)$</span> IO операций, работаем в <span class="inlineMath">$B$</span> раз хуже, чем в обычной модели.</li>
</ul>
<h4 id="reverse-массива"><a aria-hidden="true" href="#reverse-массива"><span class="icon icon-link"></span></a>Reverse массива</h4>
<p><span class="inlineMath">$O(N / B)$</span> операций, если в память помещается два блока (читаем два противоположных блока, за <span class="inlineMath">$O(1)$</span> переворачиваем элементы в блоках, записываем их на противоположные места).</p>
<h3 id="Сортировка"><a aria-hidden="true" href="#Сортировка"><span class="icon icon-link"></span></a>Сортировка</h3>
<p>Используем аналог обычного merge-sort. Его можно обозвать 2-way merge-sort, т.к. на вход merge подается два отсортированных куска, и они мерджатся.</p>
<p>Мы же будем использовать <span class="inlineMath">$K$</span>-way merge-sort.</p>
<p>Давайте возьмем <span class="inlineMath">$K = \Theta\left(\frac MB - 1\right)$</span> (<span class="inlineMath">$-1$</span> нужен для того, чтобы у нас осталось место для буфера, который мы будем записывать в память). Как работает merger: в <span class="inlineMath">$\frac MB - 1$</span> блоков записываем по одному блоку из каждого отсортированного куска, в последнем блоке у нас буфер, в который мы сливаем массивы. Если буфер переполняется, мы записываем его во внешнюю память, если кончается какой-то блок из подмассива, то мы читаем следующий блок.</p>
<p>Общая схема алгорима:
1. Разбить <span class="inlineMath">$A$</span> на <span class="inlineMath">$K$</span> массивов
2. Рекурсивно отсортировать каждый
3. Слить при помощи <span class="inlineMath">$K$</span>-merge</p>
<p>Уровней рекурсии: <span class="inlineMath">$O\left(\frac NB \cdot \log_{\frac MB} \frac NB \right)$</span>
Время работы: <span class="inlineMath">$T(N) = K \cdot T(N/K) + \Theta(N/B)$</span></p>
<h2 id="Модель-cache-oblivious"><a aria-hidden="true" href="#Модель-cache-oblivious"><span class="icon icon-link"></span></a>Модель cache-oblivious</h2>
<p>В данной моели неизвестны <span class="inlineMath">$M$</span> и <span class="inlineMath">$B$</span>. Также мы не контролируем поведение загруженных блоков в RAM (нет произвольного выделения/освобождения памяти).</p>
<p>Есть CPU и RAM, между ними есть несколько уровней кешей (обычно три для CPU). Если алгоритм <span class="inlineMath">$A$</span> cache-oblivious оптимальный. то он оптимальный для любой иерархии кешей.</p>
<p>Не смотря на все ограничения, алгоритм поиска в массиве из модели с внешней памятью останется оптимальным.</p>
<p>Предположения модели:
1. <span class="inlineMath">$M \geq B^2$</span> -- предположение о высоте кеша, количество элементов в блоке не меньше, чем число блоков в кеше
2. Кеш ассоциативен: если есть кеш с блоками, то в любой блок можно записать любой блок из памяти (в реальных процессорных кешах это не так, там каждый кусочек кеша имеет доступ только к некоторому подмножеству памяти)
3. Стратегия управения кешом оптимальна. Стратегия отвечает на вопрос, что делать, если кеш переполнился:
- LRU -- Last Resently Used: выкидывается блок, который дольше всего не использовался
- FIFO: выкидывается самый старый загруженный блок</p>
<p><strong>Теорема:</strong> если оптимальная стратегия сделает <span class="inlineMath">$f$</span> чтений для кеша размера <span class="inlineMath">$M / 2$</span>, то LRU (FIFO) сделает <span class="inlineMath">$\leq 2f$</span> чтений для кеша размера <span class="inlineMath">$M$</span>.</p>
<p><strong>Доп. свойство для алгоритмов (условие регулярности):</strong> <span class="inlineMath">$T(B, M / 2) = O(T(B, M))$</span>.</p>
<p><strong>Утверждение:</strong> Если алгоритм <span class="inlineMath">$A$</span> в предполежении оптимальной стратегии управения кешем <span class="inlineMath">$T(B, M)$</span>, то если мы перейдем от оптимальной стратегии к LRU (FIFO), то он будет работать <span class="inlineMath">$\Theta(T(B, M))$</span> (увеличится в константу раз).</p>
<p><strong>Доказательство теоремы:</strong> рассмотрим последовательность чтений для LRU. Разобьем их на кусочки <span class="inlineMath">$s_i$</span>, в которых количество чтений LRU меньше размера кеша <span class="inlineMath">$(M/ B)$</span>, <span class="inlineMath">$f = M/B - 1$</span>. Оптимальная стратегия считает <span class="inlineMath">$f - M/2B = f / 2$</span> чтений.</p>
<h3 id="Сортировка-1"><a aria-hidden="true" href="#Сортировка-1"><span class="icon icon-link"></span></a>Сортировка</h3>
<p><span class="inlineMath">$k$</span>-воронка (<span class="inlineMath">$k$</span>-funnel) -- структрура данных, которая сливает <span class="inlineMath">$k^3$</span> (<span class="inlineMath">$k$</span> такое, что <span class="inlineMath">$k^3 = B$</span>) отсортированных массивов (списков) за <span class="inlineMath">$O\left(\frac{k^3}B \log_{\frac MB}\frac{k^3}B + k\right)$</span>, требует <span class="inlineMath">$O(k^2)$</span> памяти.</p>
<p>Алгоритм:
1. Разбиваем вход на массивы размера <span class="inlineMath">$N^{\frac 23}$</span>, получим <span class="inlineMath">$N^{\frac 13}$</span> подмассивов
2. Рекурсивно сортируем
3. Сливаем при помощи <span class="inlineMath">$k$</span>-воронки</p>
<p>Время работы: <span class="inlineMath">$T(N) = N^{\frac 13}\cdot T(N^{\frac 23}) + O\left(\frac{k^3}B \log_{\frac MB}\frac{k^3}B + N^{\frac 13}\right)$</span>, если <span class="inlineMath">$N\geq B^2$</span>, то тогда можно выкинуть <span class="inlineMath">$N^{\frac 13}$</span> из <span class="inlineMath">$O(...)$</span>, и итоговое время работы будет <span class="inlineMath">$T(N) = O\left(\frac{k^3}B \log_{\frac MB}\frac{k^3}B\right)$</span></p>
<script>
var terms = {};
</script>

      
      <div class="navigation">
          <a href="lec_2_09.html">← взад</a>
          <a href="index.html">на главную</a>
          <a href="lec_2_11.html">вперёд →</a>
      </div>
      

      
  </article>
<script src="https://demiurg906.github.io/au-algorithms-sem_1/assets/popup.js"></script>
</body>
</html>